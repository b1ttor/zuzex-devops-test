# zuzex-devops-test
Тестовое задание на позицию DevOps-engineer в компании zuzex

Перед выполнением задач: на системе должен полноценно работать docker и быть установлен docker-compose (версия не критична). Образы docker использовать из официального hub.docker.com. Можно (и нужно) пользоваться всеми доступными средствами. Постарайтесь выполнить максимум из возможного.
Важные условия:
•	Каждое выполненное задание должно находиться в своей отдельной директории
•	Каждое задание должно быть полностью отлажено: легко подниматься и останавливаться командами docker-compose up/down без каких-либо сторонних правок в docker-compose.yml (!)
•	Итоговый результат на проверку присылать в виде zip-архива
# Задание 1.1 - Расписать docker-compose.yml, который разворачивает Wordpress CMS вместе c phpMyAdmin
Требования:
1.	Используемые docker-образы должны быть фиксированных версий, а сами версии ПО должны быть актуальными (сверьтесь по https://endoflife.date/)
2.	Контейнер с wordpress должен быть доступен на 4000-ом порту docker-хоста. Контейнер с phpMyAdmin - на 4001-ом 
3.	При запуске mysql контейнера должна создаваться база данных с именем wp_db. Пользователь и его пароль для подключения могут быть произвольными
4.	Настройки подключения wordpress к mysql должны быть заранее заданы через docker-compose.yml, тем самым минуя настройку подключения к БД через UI wordpress 
5.	Контейнеры wordpress и phpmyadmin должны стартовать после успешного запуска контейнера mysql 
6.	Исходники wordpress, находящиеся в контейнере, должны быть доступны в файловой системе docker-хоста из директории data/wp, находящейся рядом с docker-compose.yml. Аналогично и для контейнера mysql c его БД — доступ из директории data/mysql
7.	При попадании на главную страницу phpmyadmin, должна отображаться форма авторизации к БД mysql, а само подключение к БД происходить без проблем
8.	Сделать так, чтобы для phpmyadmin не приходилось на форме авторизации указывать mysql-хост для подключения 
9.	Организовать healthcheck для контейнера mysql
10.	Оформить все чувствительные данные (логины/пароли) через переменные в .env файле

Результат выполненного задания будет оцениваться по написанному docker-compose.yml файлу (директорию data с исходниками и данными в результирующий архив добавлять не нужно) 
# Задание 1.2 - Добавление веб-сервера
Предположим, что мы хотим развернуть наш docker-compose.yml на выделенном сервере, где будут открыты только http и https порты. Специально для этого мы внесём правки в docker-compose.yml и протестируем всё у себя на локальной машине...

Требования:
1.	Добавить к созданному в предыдущем задании docker-compose.yml контейнер с nginx (или любым другим web-сервером), который будет использоваться в качестве reverse proxy. Версия ПО также должна быть фиксированной и актуальной
2.	Веб-сервер должен иметь host network. Если есть проблема с конфликтом портов между контейнером и хостом - решить её
3.	Файл конфига веб-сервера должен находиться по соседству с docker-compose.yml и монтироваться через volume по нужному пути
4.	Посредством reverse proxy, сконфигурировать веб-сервер таким образом, чтобы: 
•	при обращении по корневому пути localhost (/) открывался wordpress-сайт 
•	по пути localhost/wp-admin открывалась админка wordpress 
•	по пути localhost/phpmyadmin открывался phpmyadmin (для корректной работы phpmyadmin в таком режим режиме, используйте environment-переменную PMA_ABSOLUTE_URI и обратите внимание на слэши эндпоинтов в самом веб-конфиге)
5.	Скорректируйте проброс портов у сервисов wordpress/phpmyadmin/mysql так, чтобы они были доступны только на localhost интерфейсе
6.	После того как вы убедитесь в стабильности работы всего стека — организуйте автоматический перезапуск контейнеров при их падении или остановке

Результат выполненного задания будет оцениваться по написанному конфигу веб-сервера и модифицированному docker-compose.yml файлу
 
# Задание 1.3 - Мониторинг
Требования:
1.	Взять наработки из предыдущих заданий и добавить к ним стэк Grafana + Prometheus + node_exporter (можно найти и взять из готового compose). Также используем актуальные версии и фиксируем их
2.	Сконфигурировать отдельным файлом scrape_config для Prometheus добавив эндпоинт развёрнутого node_exporter. Через volume монтировать этот конфиг в контейнер prometheus по нужному пути
3.	Организовать и вынести логин/пароль для авторизации Grafana в .env файл
4.	Через UI Grafana проверить в настройках соединение с контейнером Prometheus в качестве datasource. Добавить готовый дашборд в Grafana для вывода метрик node_exporter. Проверить корректность вывода собранных метрик и сделать несколько развернутых скриншотов дашборда
5.	Переорганизовать конфигурацию datasource для Grafana через конфиг-файл, и также монтировать его через volume директиву по нужному пути
6.	Дополнить конфиг веб-сервера добавив путь localhost/grafana, который будет открывать UI Grafana. Воспользуйтесь соответствующими инструкциями по офф. документации

Результат выполненного задания будет оцениваться по:
•	модифицированному docker-compose.yml файлу и конфигу веб-сервера
•	конфиг-файлам Prometheus и datasource Grafana
•	скриншотам Grafana-дашборда с метриками

